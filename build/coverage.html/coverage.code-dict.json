{"/home/travis/build/npmtest/node-npmtest-liquid-fire/test.js":"/* istanbul instrument in package npmtest_liquid_fire */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/lib.npmtest_liquid_fire.js":"/* istanbul instrument in package npmtest_liquid_fire */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_liquid_fire = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_liquid_fire = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-liquid-fire && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_liquid_fire */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_liquid_fire\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_liquid_fire.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_liquid_fire.rollup.js'] =\n            local.assetsDict['/assets.npmtest_liquid_fire.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_liquid_fire.__dirname + '/lib.npmtest_liquid_fire.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/index.js":"/*jshint node: true, esversion: 5 */\n'use strict';\n\nvar VersionChecker = require('ember-cli-version-checker');\nvar path = require('path');\nvar mergeTrees = require('broccoli-merge-trees');\nvar Funnel = require('broccoli-funnel');\n\nmodule.exports = {\n  name: 'liquid-fire',\n\n  init: function() {\n    if (this._super.init) {\n      this._super.init.apply(this, arguments);\n    }\n\n    this.versionChecker = new VersionChecker(this);\n    this.versionChecker.for('ember-cli', 'npm').assertAbove('0.2.0');\n\n    // Shim this.import for Engines support\n    if (!this.import) {\n      // Shim from https://github.com/ember-cli/ember-cli/blob/5d64cfbf1276cf1e3eb88761df4546c891b5efa6/lib/models/addon.js#L387\n      this._findHost = function findHostShim() {\n        var current = this;\n        var app;\n\n        // Keep iterating upward until we don't have a grandparent.\n        // Has to do this grandparent check because at some point we hit the project.\n        do {\n          app = current.app || app;\n        } while (current.parent.parent && (current = current.parent));\n\n        return app;\n      };\n      // Shim from https://github.com/ember-cli/ember-cli/blob/5d64cfbf1276cf1e3eb88761df4546c891b5efa6/lib/models/addon.js#L443\n      this.import = function importShim(asset, options) {\n        var app = this._findHost();\n        app.import(asset, options);\n      };\n    }\n  },\n\n\n  treeForAddon: function(_tree) {\n    var tree = this._versionSpecificTree('addon', _tree);\n    return this._super.treeForAddon.call(this, tree);\n  },\n\n  treeForAddonTemplates: function(_tree) {\n    var tree = this._versionSpecificTree('templates', _tree);\n    return this._super.treeForAddonTemplates.call(this, tree);\n  },\n\n  _versionSpecificTree: function(which, tree) {\n    var emberVersion = this.versionChecker.forEmber();\n\n    if ((emberVersion.gt('2.9.0-beta') && emberVersion.lt('2.9.0'))|| emberVersion.gt('2.10.0-alpha')) {\n      return this._withVersionSpecific(which, tree, '2.9');\n    } else if (!emberVersion.lt('1.13.0')) {\n      return this._withVersionSpecific(which, tree, '1.13');\n    } else {\n      throw new Error(\"This version of liquid-fire supports Ember versions >= 1.13.0.\");\n    }\n  },\n\n  _withVersionSpecific: function(which, tree, version) {\n    var versionSpecificPath = path.join(this.root, 'version-specific-' + version);\n    var destDir;\n    var include;\n\n    if (which === 'templates') {\n      destDir = 'version-specific';\n      include = [\"*.hbs\"];\n    } else {\n      destDir = 'ember-internals/version-specific';\n    }\n\n    var funneled = new Funnel(versionSpecificPath, {\n      include: include,\n      destDir: destDir\n    });\n\n    return mergeTrees([tree, funneled]);\n  },\n\n  treeForVendor: function(tree){\n    var velocityPath = path.dirname(require.resolve('velocity-animate'));\n    var velocityTree = new Funnel(this.treeGenerator(velocityPath), {\n      srcDir: '/',\n      destDir: 'velocity'\n    });\n\n    var matchMediaPath = path.dirname(require.resolve('match-media'));\n    var matchMediaTree = new Funnel(this.treeGenerator(matchMediaPath), {\n      srcDir: '/',\n      destDir: 'match-media'\n    });\n\n    return mergeTrees([tree, velocityTree, matchMediaTree]);\n  },\n\n  included: function(app){\n    if (process.env.EMBER_CLI_FASTBOOT) {\n      // in fastboot we use the shim by itself, which will make\n      // importing velocity a noop.\n      this.import('vendor/shims/velocity.js');\n    } else if (this._hasShimAMDSupport()) {\n      // if this ember-cli is new enough to do amd imports\n      // automatically, use that\n      this.import('vendor/velocity/velocity.js', {\n        using: [{\n          transformation: 'amd', as: 'velocity'\n        }]\n      });\n    } else {\n      // otherwise apply our own amd shim\n      this.import('vendor/velocity/velocity.js');\n      this.import('vendor/shims/velocity.js');\n    }\n\n    if (!process.env.EMBER_CLI_FASTBOOT) {\n      this.import('vendor/match-media/matchMedia.js');\n    }\n\n    this.import('vendor/liquid-fire.css');\n  },\n\n  _hasShimAMDSupport: function(){\n    var app = this._findHost();\n    return 'amdModuleNames' in app;\n  }\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/action.js":"import Promise from \"./promise\";\n\nexport default class Action {\n  constructor(nameOrHandler, args=[], opts={}) {\n    if (typeof nameOrHandler === 'function') {\n      this.handler = nameOrHandler;\n    } else {\n      this.name = nameOrHandler;\n    }\n    this.reversed = opts.reversed;\n    this.args = args;\n  }\n\n  validateHandler(transitionMap) {\n    if (!this.handler) {\n      this.handler = transitionMap.lookup(this.name);\n    }\n  }\n\n  run(context) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(this.handler.apply(context, this.args)).then(resolve, reject);\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/animate.js":"/* jshint newcap: false */\nimport Promise from \"./promise\";\nimport Ember from \"ember\";\nimport Velocity from \"velocity\";\n\n// Make sure Velocity always has promise support by injecting our own\n// RSVP-based implementation if it doesn't already have one.\nif (!Velocity.Promise) {\n  Velocity.Promise = Promise;\n}\n\n// Velocity's tick() defaults to RAF's high resolution timestamp. If the browser\n// is under high stress the RAF timestamp may have a significant offset which\n// can result in dropping a large chunk of frames. Because of this, the use of\n// the RAF timestamp should be opt-in.\nVelocity.timestamp = false;\n\nexport function animate(elt, props, opts, label) {\n  // These numbers are just sane defaults in the probably-impossible\n  // case where somebody tries to read our state before the first\n  // 'progress' callback has fired.\n  var state = { percentComplete: 0, timeRemaining: 100, timeSpent: 0 };\n\n  if (!elt || elt.length === 0) {\n    return Promise.resolve();\n  }\n\n  if (!opts) {\n    opts = {};\n  } else {\n    opts = Ember.copy(opts);\n  }\n\n  // By default, we ask velocity to clear the element's `display`\n  // and `visibility` properties at the start of animation. Our\n  // animated divs are all initially rendered with `display:none`\n  // and `visibility:hidden` to prevent a flash of before-animated\n  // content.\n  if (typeof(opts.display) === 'undefined') {\n    opts.display = '';\n  }\n  if (typeof(opts.visibility) === 'undefined') {\n    opts.visibility = 'visible';\n  }\n\n  if (opts.progress) {\n    throw new Error(\"liquid-fire's 'animate' function reserves the use of Velocity's 'progress' option for its own nefarious purposes.\");\n  }\n\n  opts.progress = function(){\n    state.percentComplete = arguments[1];\n    state.timeRemaining = arguments[2];\n    state.timeSpent = state.timeRemaining / (1/state.percentComplete - 1);\n  };\n\n  state.promise = Promise.resolve(Velocity.animate(elt[0], props, opts));\n\n  if (label) {\n    state.promise = state.promise.then(function(){\n      clearLabel(elt, label);\n    }, function(err) {\n      clearLabel(elt, label);\n      throw err;\n    });\n    applyLabel(elt, label, state);\n  }\n\n  return state.promise;\n}\n\nexport function stop(elt) {\n  if (elt) {\n    Velocity(elt[0], 'stop', true);\n  }\n}\n\nexport function setDefaults(props) {\n  for (var key in props) {\n    if (props.hasOwnProperty(key)) {\n      if (key === 'progress') {\n        throw new Error(\"liquid-fire's 'animate' function reserves the use of Velocity's '\" + key + \"' option for its own nefarious purposes.\");\n      }\n      Velocity.defaults[key] = props[key];\n    }\n  }\n}\n\nexport function isAnimating(elt, animationLabel) {\n  return elt && elt.data('lfTags_' + animationLabel);\n}\n\nexport function finish(elt, animationLabel) {\n  return stateForLabel(elt, animationLabel).promise;\n}\n\nexport function timeSpent(elt, animationLabel) {\n  return stateForLabel(elt, animationLabel).timeSpent;\n}\n\nexport function timeRemaining(elt, animationLabel) {\n  return stateForLabel(elt, animationLabel).timeRemaining;\n}\n\n\nfunction stateForLabel(elt, label) {\n  var state = isAnimating(elt, label);\n  if (!state) {\n    throw new Error(\"no animation labeled \" + label + \" is in progress\");\n  }\n  return state;\n}\n\nfunction applyLabel(elt, label, state) {\n  if (elt){\n    elt.data('lfTags_' + label, state);\n  }\n}\n\nfunction clearLabel(elt, label) {\n  if (elt) {\n    elt.data('lfTags_' + label, null);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/constrainables.js":"import { childRoute, routeName, routeModel } from \"liquid-fire/ember-internals\";\n\nexport default {\n  oldValue : {\n    reversesTo: 'newValue',\n    accessor: function(conditions) {\n      return [versionValue(conditions, 1)];\n    }\n  },\n  newValue: {\n    reversesTo: 'oldValue',\n    accessor: function(conditions) {\n      return [versionValue(conditions, 0)];\n    }\n  },\n  oldRoute: {\n    reversesTo: 'newRoute',\n    accessor: function(conditions) {\n      return routeName(childRoute(versionValue(conditions, 1), conditions.matchContext.outletName));\n    }\n  },\n  newRoute: {\n    reversesTo: 'oldRoute',\n    accessor: function(conditions) {\n      return routeName(childRoute(versionValue(conditions, 0), conditions.matchContext.outletName));\n    }\n  },\n  oldModel: {\n    reversesTo: 'newModel',\n    accessor: function(conditions) {\n      return routeModel(childRoute(versionValue(conditions, 1), conditions.matchContext.outletName));\n    }\n  },\n  newModel: {\n    reversesTo: 'oldModel',\n    accessor: function(conditions) {\n      return routeModel(childRoute(versionValue(conditions, 0), conditions.matchContext.outletName));\n    }\n  },\n  helperName: {\n    accessor(conditions) {\n      return conditions.matchContext.helperName;\n    }\n  },\n  outletName: {\n    accessor(conditions) {\n      return conditions.matchContext.outletName;\n    }\n  },\n  parentElementClass: {\n    accessor: function(conditions) {\n      var cls = conditions.parentElement.attr('class');\n      if (cls) {\n        return cls.split(/\\s+/);\n      }\n    }\n  },\n  parentElement: {},\n  firstTime: {},\n  media: {}\n};\n\nfunction versionValue(conditions, index) {\n  var versions = conditions.versions;\n  return versions[index] ? versions[index].value : null;\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/constraint.js":"import Ember from \"ember\";\nimport constrainables from \"./constrainables\";\n\n// Every rule constraint has a target and either `keys` or\n// `predicate`. key-based constraints are cheaper because we can check\n// them with O(1) lookups, whereas predicates must be searched O(n).\nexport default class Constraint {\n  constructor(target, matcher) {\n    // targets are the properties of a transition that we can\n    // constrain\n    this.target = target;\n    if (arguments.length === 1) { return; }\n    if (matcher instanceof RegExp) {\n      this.predicate = function(value) { return matcher.test(value); };\n    } else if (typeof matcher === 'function') {\n      this.predicate = matcher;\n    } else if (typeof matcher === 'boolean') {\n      this.predicate = function(value) { return matcher ? value : !value; };\n    } else {\n      this.keys = constraintKeys(matcher);\n    }\n  }\n\n  invert() {\n    if (!constrainables[this.target].reversesTo) {\n      return this;\n    }\n    var inverse = new this.constructor(constrainables[this.target].reversesTo);\n    inverse.predicate = this.predicate;\n    inverse.keys = this.keys;\n    return inverse;\n  }\n}\n\nexport var EMPTY = '__liquid_fire_EMPTY__';\nexport var ANY = '__liquid_fire_ANY__';\n\nexport function constraintKeys(matcher) {\n  if (typeof matcher === 'undefined' || matcher === null) {\n    matcher = [ EMPTY ];\n  } else if (!Ember.isArray(matcher)) {\n    matcher = [matcher];\n  }\n  return Ember.A(matcher).map((elt) => {\n    if (typeof elt === 'string') {\n      return elt;\n    } else {\n      return Ember.guidFor(elt);\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/constraints.js":"/* eslint-disable no-console */\n\nimport Ember from 'ember';\nimport { constraintKeys, EMPTY, ANY } from './constraint';\nimport constrainables from \"./constrainables\";\n\nexport default class Constraints {\n  constructor() {\n    this.targets = {};\n    this.ruleCounter = 0;\n    for (var i = 0; i < constrainableKeys.length; i++) {\n      this.targets[constrainableKeys[i]] = {};\n    }\n  }\n\n  addRule(rule) {\n    rule.id = this.ruleCounter++;\n    if (rule.debug) {\n      this.debug = true;\n    }\n    this.addHalfRule(rule);\n    if (rule.reverse) {\n      var inverted = rule.invert();\n      inverted.id = rule.id + ' reverse';\n      this.addHalfRule(inverted);\n    }\n  }\n\n  addHalfRule(rule) {\n    var seen = {};\n    rule.constraints.forEach((constraint) => {\n      seen[constraint.target] = true;\n      this.addConstraint(rule, constraint);\n    });\n    constrainableKeys.forEach((key) => {\n      if (!seen[key]) {\n        this.addConstraint(rule, { target: key });\n      }\n    });\n  }\n\n  addConstraint(rule, constraint) {\n    var context = this.targets[constraint.target];\n    if (!context) {\n      throw new Error(`Unknown constraint target ${constraint.target}`);\n    }\n    if (constraint.keys) {\n      constraint.keys.forEach((key) => {\n        this.addKey(context, key, rule);\n      });\n    } else {\n      this.addKey(context, ANY, rule);\n    }\n  }\n\n  addKey(context, key, rule) {\n    if (!context[key]) {\n      context[key] = {};\n    }\n    context[key][Ember.guidFor(rule)] = rule;\n  }\n\n  bestMatch(conditions) {\n    if (this.debug) {\n      console.log(\"[liquid-fire] Checking transition rules for\", conditions.parentElement[0]);\n    }\n\n    var rules = this.match(conditions);\n    var best = highestPriority(rules);\n\n    if (rules.length > 1 && this.debug) {\n      rules.forEach((rule) => {\n        if (rule !== best && rule.debug) {\n          console.log(`${describeRule(rule)} matched, but it was superceded by another rule`);\n        }\n      });\n    }\n    if (best && best.debug) {\n      console.log(`${describeRule(best)} matched`);\n    }\n    return best;\n  }\n\n  match(conditions) {\n    var rules = this.matchByKeys(conditions);\n    rules = this.matchPredicates(conditions, rules);\n    return rules;\n  }\n\n  matchByKeys(conditions) {\n    var matchSets = [];\n    for (var i = 0; i < constrainableKeys.length; i++) {\n      var key = constrainableKeys[i];\n      var value = conditionAccessor(conditions, key);\n      matchSets.push(this.matchingSet(key, value));\n    }\n    return intersection(matchSets);\n  }\n\n  matchingSet(prop, value) {\n    var keys = constraintKeys(value);\n    var context = this.targets[prop];\n    var matched = Ember.A();\n    for (var i = 0; i < keys.length; i++) {\n      if (context[keys[i]]) {\n        matched.push(context[keys[i]]);\n      }\n    }\n    if (keys.length === 0 && context[EMPTY]) {\n      matched.push(context[EMPTY]);\n    }\n    if (context[ANY]) {\n      matched.push(context[ANY]);\n    }\n    matched = union(matched);\n    if (this.debug) {\n      this.logDebugRules(matched, context, prop, value);\n    }\n    return matched;\n  }\n\n  logDebugRules(matched, context, target, value) {\n    Ember.A(Object.keys(context)).forEach((setKey) => {\n      var set = context[setKey];\n      Ember.A(Object.keys(set)).forEach((ruleKey) => {\n        var rule = set[ruleKey];\n        if (rule.debug && !matched[Ember.guidFor(rule)]) {\n          console.log(`${describeRule(rule)} rejected because ${target} was`, ...value);\n        }\n      });\n    });\n  }\n\n  matchPredicates(conditions, rules) {\n    var output = [];\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var matched = true;\n      for (var j = 0; j < rule.constraints.length; j++) {\n        var constraint = rule.constraints[j];\n        if (constraint.predicate && !this.matchConstraintPredicate(conditions, rule, constraint)) {\n          matched = false;\n          break;\n        }\n      }\n      if (matched) {\n        output.push(rule);\n      }\n    }\n    return output;\n  }\n\n  matchConstraintPredicate(conditions, rule, constraint) {\n    var values = conditionAccessor(conditions, constraint.target);\n    var reverse = constrainables[constraint.target].reversesTo;\n    var inverseValues;\n    if (reverse) {\n      inverseValues = conditionAccessor(conditions, reverse);\n    }\n    for (var i = 0; i < values.length; i++) {\n      if (constraint.predicate(values[i], inverseValues ? inverseValues[i] : null)) {\n        return true;\n      }\n    }\n    if (rule.debug) {\n      if (constraint.target === 'parentElement') {\n        values = values.map((v)=>v[0]);\n      }\n      console.log(`${describeRule(rule)} rejected because of a constraint on ${constraint.target}. ${constraint.target} was`, ...values);\n    }\n  }\n}\n\nfunction conditionAccessor(conditions, key) {\n  var constrainable = constrainables[key];\n  if (constrainable.accessor) {\n    return constrainable.accessor(conditions) || [];\n  } else {\n    return [conditions[key]];\n  }\n}\n\n// Returns a list of property values from source whose keys also\n// appear in all of the rest objects.\nfunction intersection(sets) {\n  var source = sets[0];\n  var rest = sets.slice(1);\n  var keys = Object.keys(source);\n  var keysLength = keys.length;\n  var restLength = rest.length;\n  var result = [];\n  for (var keyIndex = 0; keyIndex < keysLength; keyIndex++) {\n    var key = keys[keyIndex];\n    var matched = true;\n    for (var restIndex = 0; restIndex < restLength; restIndex++) {\n      if (!rest[restIndex].hasOwnProperty(key)) {\n        matched = false;\n        break;\n      }\n    }\n    if (matched) {\n      result.push(source[key]);\n    }\n  }\n  return result;\n}\n\nfunction union(sets) {\n  var setsLength = sets.length;\n  var output = {};\n  for (var i = 0; i < setsLength; i++) {\n    var set = sets[i];\n    var keys = Object.keys(set);\n    for (var j = 0; j < keys.length; j++) {\n      var key = keys[j];\n      output[key] = set[key];\n    }\n  }\n  return output;\n}\n\nfunction describeRule(rule) {\n  return `[liquid-fire rule ${rule.id}]`;\n}\n\nfunction highestPriority(rules) {\n  var best;\n  var bestScore = 0;\n  for (var i = 0; i < rules.length; i++) {\n    var rule = rules[i];\n    var score = rules[i].constraints.length;\n    if (!best || score > bestScore || (score === bestScore && rule.id > best.id)) {\n      best = rule;\n      bestScore = score;\n    }\n  }\n  return best;\n}\n\nvar constrainableKeys = Ember.A(Object.keys(constrainables));\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/dsl.js":"import { setDefaults } from \"./animate\";\nimport Rule from \"./rule\";\nimport Constraint from \"./constraint\";\nimport Action from \"./action\";\n\nexport default class DSL {\n\n  constructor(map, constraints) {\n    this.map = map;\n    this.constraints = constraints;\n  }\n\n  setDefault(props) {\n    setDefaults(props);\n  }\n\n  transition() {\n    var rule = new Rule();\n    var parts = Array.prototype.slice.apply(arguments).reduce(function(a,b){\n      return a.concat(b);\n    }, []);\n\n    for (var i = 0; i < parts.length; i++) {\n      rule.add(parts[i]);\n    }\n\n    rule.validate(this.map);\n    this.constraints.addRule(rule);\n  }\n\n  fromRoute(routeName) {\n    return [\n      new Constraint('oldRoute', routeName)\n    ];\n  }\n\n  toRoute(routeName) {\n    return [\n      new Constraint('newRoute', routeName)\n    ];\n  }\n\n  withinRoute(routeName) {\n    return this.fromRoute(routeName).concat(this.toRoute(routeName));\n  }\n\n  fromValue(matcher) {\n    return [\n      new Constraint('oldValue', matcher)\n    ];\n  }\n\n  toValue(matcher) {\n    return [\n      new Constraint('newValue', matcher)\n    ];\n  }\n\n  betweenValues(matcher) {\n    return this.fromValue(matcher).concat(this.toValue(matcher));\n  }\n\n  fromModel(matcher) {\n    return [\n      new Constraint('oldModel', matcher)\n    ];\n  }\n\n  toModel(matcher) {\n    return [\n      new Constraint('newModel', matcher)\n    ];\n  }\n\n  betweenModels(matcher) {\n    return this.fromModel(matcher).concat(this.toModel(matcher));\n  }\n\n  hasClass(name) {\n    return new Constraint('parentElementClass', name);\n  }\n\n  matchSelector(selector) {\n    return new Constraint('parentElement', function(elt) {\n      return elt.is(selector);\n    });\n  }\n\n  childOf(selector) {\n    return this.matchSelector(selector + ' > *');\n  }\n\n  use(nameOrHandler, ...args) {\n    return new Action(nameOrHandler, args);\n  }\n\n  reverse(nameOrHandler, ...args) {\n    return new Action(nameOrHandler, args, { reversed: true });\n  }\n\n  useAndReverse(nameOrHandler, ...args) {\n    return [\n      this.use(nameOrHandler, ...args),\n      this.reverse(nameOrHandler, ...args)\n    ];\n  }\n\n  onInitialRender() {\n    return new Constraint('firstTime', 'yes');\n  }\n\n  includingInitialRender() {\n    return new Constraint('firstTime', ['yes', 'no']);\n  }\n\n  inHelper(...names) {\n    return new Constraint('helperName', names);\n  }\n\n  outletName(...names) {\n    return new Constraint('outletName', names);\n  }\n\n  media(query) {\n    return new Constraint('media', function() {\n      return window.matchMedia(query).matches;\n    });\n  }\n\n  debug() {\n    return 'debug';\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/ember-internals.js":"/*\n  This module is intended to encapsulate all the known places where\n  liquid-fire depends on non-public Ember APIs.\n\n  See also tests/helpers/ember-testing-internals.js, which does the\n  same thing but for code that is only needed in the test environment.\n\n */\n\n// These things are the same for all supported Ember versions.\nexport {\n  childRoute,\n  routeName,\n  routeModel,\n  routeIsStable,\n  modelIsStable\n} from './ember-internals/common';\n\n// These things are swapped out at build time based on the Ember\n// version.\nexport {\n  containingElement,\n  initialize,\n  getOutletStateTemplate\n} from './ember-internals/version-specific';\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/growable.js":"/* jshint newcap: false */\nimport Ember from \"ember\";\nimport Promise from \"liquid-fire/promise\";\nimport Velocity from \"velocity\";\nvar capitalize = Ember.String.capitalize;\n\nexport default Ember.Mixin.create({\n  growDuration: 250,\n  growPixelsPerSecond: 200,\n  growEasing: 'slide',\n  shrinkDelay: 0,\n  growDelay: 0,\n  growWidth: true,\n  growHeight: true,\n\n  transitionMap: Ember.inject.service('liquid-fire-transitions'),\n\n  animateGrowth: function(elt, have, want) {\n    this.get('transitionMap').incrementRunningTransitions();\n    var adaptations = [];\n\n    if (this.get('growWidth')) {\n      adaptations.push(this._adaptDimension(elt, 'width', have, want));\n    }\n\n    if (this.get('growHeight')) {\n      adaptations.push(this._adaptDimension(elt, 'height', have, want));\n    }\n\n    return Promise.all(adaptations).then(()=>{\n      this.get('transitionMap').decrementRunningTransitions();\n    });\n  },\n\n  _adaptDimension: function(elt, dimension, have, want) {\n    if (have[dimension] === want[dimension]) {\n      return Promise.resolve();\n    }\n    var target = {};\n    target['outer'+capitalize(dimension)] = [\n      want[dimension],\n      have[dimension],\n    ];\n    return Velocity(elt[0], target, {\n      delay: this._delayFor(have[dimension], want[dimension]),\n      duration: this._durationFor(have[dimension], want[dimension]),\n      queue: false,\n      easing: this.get('growEasing') || this.constructor.prototype.growEasing\n    });\n  },\n\n  _delayFor: function(before, after) {\n    if (before > after) {\n      return this.get('shrinkDelay') || this.constructor.prototype.shrinkDelay;\n    }\n\n    return this.get('growDelay') || this.constructor.prototype.growDelay;\n  },\n\n  _durationFor: function(before, after) {\n    return Math.min(this.get('growDuration') || this.constructor.prototype.growDuration, 1000*Math.abs(before - after)/(this.get('growPixelsPerSecond') || this.constructor.prototype.growPixelsPerSecond));\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/is-browser.js":"export default function isBrowser() {\n  return (typeof window !== 'undefined') && window && (typeof document !== 'undefined') && document;\n}","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/mutation-observer.js":"import isBrowser from './is-browser';\nvar activePollers = [];\n\nfunction MutationPoller(callback){\n  this.callback = callback;\n}\n\nMutationPoller.prototype = {\n  observe: function(){\n    this.interval = setInterval(this.callback, 100);\n    activePollers.push(this);\n  },\n  disconnect: function() {\n    clearInterval(this.interval);\n    activePollers.splice(activePollers.indexOf(this), 1);\n  }\n};\n\nvar M;\nif (isBrowser()) {\n  M = (window.MutationObserver || window.WebkitMutationObserver || MutationPoller);\n} else {\n  M = MutationPoller;\n}\n\n\nexport default M;\n\n// PhantomJS does not have real mutation observers, so to get\n// reasonable test timing we have to manually kick it.\nexport function testingKick() {\n  for (var i = 0; i < activePollers.length; i ++) {\n    activePollers[i].callback();\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/promise.js":"// Ember is already polyfilling Promise as needed, so just use that.\nimport Ember from \"ember\";\nexport default Ember.RSVP.Promise;\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/rule.js":"import Ember from \"ember\";\nimport Action from \"./action\";\nimport Constraint from \"./constraint\";\n\nexport default class Rule {\n  constructor() {\n    this.constraints = Ember.A();\n    this.use = null;\n    this.reverse = null;\n  }\n\n  add(thing) {\n    if (thing instanceof Action) {\n      var prop = 'use';\n      if (thing.reversed) {\n        prop = 'reverse';\n      }\n      if (this[prop]) {\n        throw new Error(`More than one \"${prop}\" statement in the same transition rule is not allowed`);\n      }\n      this[prop] = thing;\n    } else if (thing === 'debug') {\n      this.debug = true;\n    } else {\n      this.constraints.push(thing);\n    }\n  }\n\n  validate(transitionMap) {\n    if (!this.use) {\n      throw new Error(`Every transition rule must include a \"use\" statement`);\n    }\n    this.use.validateHandler(transitionMap);\n    if (this.reverse) {\n      this.reverse.validateHandler(transitionMap);\n    }\n    if (!this.constraints.find((c) => c.target === 'firstTime')) {\n      this.constraints.push(new Constraint('firstTime', 'no'));\n    }\n  }\n\n  invert() {\n    var rule = new this.constructor();\n    rule.use = this.reverse;\n    rule.reverse = this.use;\n    rule.constraints = this.constraints.map((c) => c.invert());\n    rule.debug = this.debug;\n    return rule;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/running-transition.js":"import Ember from \"ember\";\n\nexport default class RunningTransition {\n  constructor(transitionMap, versions, animation) {\n    this.transitionMap = transitionMap;\n    this.animation = animation || transitionMap.lookup('default');\n    this.animationContext = publicAnimationContext(this, versions);\n  }\n\n  run() {\n    if (this._ran) {\n      return this._ran;\n    }\n\n    this.transitionMap.incrementRunningTransitions();\n    return this._ran = this._invokeAnimation().catch((err) => {\n      // If the animation blew up, try to leave the DOM in a\n      // non-broken state as best we can before rethrowing.\n      return this.transitionMap.lookup('default').apply(this.animationContext)\n        .then(function(){ throw err; });\n    }).finally(() => {\n      this.transitionMap.decrementRunningTransitions();\n    });\n  }\n\n  interrupt() {\n    this.interrupted = true;\n    this.animationContext.oldElement = null;\n    this.animationContext.newElement = null;\n    this.animationContext.older.forEach((entry) => {\n      entry.element = null;\n    });\n  }\n\n  _invokeAnimation() {\n    return this.animation.run(this.animationContext).then(() => {\n      return this.interrupted;\n    });\n  }\n}\n\n// This defines the public set of things that user's transition\n// implementations can access as `this`.\nfunction publicAnimationContext(rt, versions) {\n  var c = {};\n  addPublicVersion(c, 'new', versions[0]);\n  if (versions[1]) {\n    addPublicVersion(c, 'old', versions[1]);\n  }\n  c.older = versions.slice(2).map((v) => {\n    var context = {};\n    addPublicVersion(context, null, v);\n    return context;\n  });\n\n  // Animations are allowed to look each other up.\n  c.lookup = function(name) {\n    return rt.transitionMap.lookup(name);\n  };\n\n  return c;\n}\n\nfunction addPublicVersion(context, prefix, version) {\n  var props = {\n    view: version.view,\n    element: version.view ? version.view.$() : null,\n    value: version.value\n  };\n  for (var key in props) {\n    var outputKey = key;\n    if (props.hasOwnProperty(key)) {\n      if (prefix) {\n        outputKey = prefix + Ember.String.capitalize(key);\n      }\n      context[outputKey] = props[key];\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/tabbable.js":"/*!\n * Adapted from jQuery UI core\n *\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n\nimport Ember from 'ember';\n\nvar $ = Ember.$;\n\nfunction focusable( element, isTabIndexNotNaN ) {\n  var nodeName = element.nodeName.toLowerCase();\n  return ( /input|select|textarea|button|object/.test( nodeName ) ?\n    !element.disabled :\n    \"a\" === nodeName ?\n      element.href || isTabIndexNotNaN :\n      isTabIndexNotNaN) && visible( element );\n}\n\nfunction visible(element) {\n  var $el = $(element);\n  return $.expr.filters.visible(element) &&\n    !$($el, $el.parents()).filter(function() {\n      return $.css( this, \"visibility\" ) === \"hidden\";\n    }).length;\n}\n\nif (!$.expr[':'].tabbable) {\n  $.expr[':'].tabbable = function( element ) {\n    var tabIndex = $.attr( element, \"tabindex\" ),\n      isTabIndexNaN = isNaN( tabIndex );\n    return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transition-map.js":"import RunningTransition from \"./running-transition\";\nimport DSL from \"./dsl\";\nimport Ember from \"ember\";\nimport Action from \"./action\";\nimport Constraints from \"./constraints\";\n\nvar TransitionMap = Ember.Service.extend({\n  init() {\n    this._super(...arguments);\n\n    this.activeCount = 0;\n    this.constraints = new Constraints();\n    var owner = Ember.getOwner(this);\n    var config;\n    if (owner.factoryFor) {\n      let maybeConfig = owner.factoryFor('transitions:main');\n      config = maybeConfig && maybeConfig.class;\n    } else {\n      config = owner._lookupFactory('transitions:main');\n    }\n    if (config) {\n      this.map(config);\n    }\n    if (Ember.testing) {\n      this._registerWaiter();\n    }\n  },\n\n  runningTransitions() {\n    return this.activeCount;\n  },\n\n  incrementRunningTransitions() {\n    this.activeCount++;\n  },\n\n  decrementRunningTransitions() {\n    this.activeCount--;\n    Ember.run.next(() => {\n      this._maybeResolveIdle();\n    });\n  },\n\n  waitUntilIdle() {\n    if (this._waitingPromise) {\n      return this._waitingPromise;\n    }\n    return this._waitingPromise = new Ember.RSVP.Promise((resolve) => {\n      this._resolveWaiting = resolve;\n      Ember.run.next(() => {\n        this._maybeResolveIdle();\n      });\n    });\n  },\n\n  _maybeResolveIdle() {\n    if (this.activeCount === 0 && this._resolveWaiting) {\n      var resolveWaiting = this._resolveWaiting;\n      this._resolveWaiting = null;\n      this._waitingPromise = null;\n      resolveWaiting();\n    }\n  },\n\n  lookup(transitionName) {\n    var owner = Ember.getOwner(this);\n    var handler;\n    if (owner.factoryFor) {\n      let maybeHandler = owner.factoryFor('transition:' + transitionName);\n      handler = maybeHandler && maybeHandler.class;\n    } else {\n      handler = owner._lookupFactory('transition:' + transitionName);\n    }\n    if (!handler) {\n      throw new Error(\"unknown transition name: \" + transitionName);\n    }\n    return handler;\n  },\n\n  defaultAction() {\n    if (!this._defaultAction) {\n      this._defaultAction = new Action(this.lookup('default'));\n    }\n    return this._defaultAction;\n  },\n\n  constraintsFor(conditions) {\n    if (conditions.rules) {\n      let constraints = new Constraints();\n      this.map(conditions.rules, constraints);\n      return constraints;\n    } else {\n      return this.constraints;\n    }\n  },\n\n  transitionFor(conditions) {\n    var action;\n    if (conditions.use && conditions.firstTime !== 'yes') {\n      action = new Action(conditions.use);\n      action.validateHandler(this);\n    } else {\n      let rule = this.constraintsFor(conditions).bestMatch(conditions);\n      if (rule) {\n        action = rule.use;\n      } else {\n        action = this.defaultAction();\n      }\n    }\n    return new RunningTransition(this, conditions.versions, action);\n  },\n\n\n  map(handler, constraints) {\n    if (handler){\n      handler.apply(new DSL(this, constraints || this.constraints));\n    }\n    return this;\n  },\n\n  _registerWaiter() {\n    var self = this;\n    this._waiter = function() {\n      return self.runningTransitions() === 0;\n    };\n    Ember.Test.registerWaiter(this._waiter);\n  },\n\n  willDestroy() {\n    if (this._waiter) {\n      Ember.Test.unregisterWaiter(this._waiter);\n      this._waiter = null;\n    }\n  }\n\n});\n\n\nTransitionMap.reopenClass({\n  map(handler) {\n    var t = TransitionMap.create();\n    t.map(handler);\n    return t;\n  }\n});\n\n\nexport default TransitionMap;\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/velocity-ext.js":"/*\n  This makes it possible to animate outerHeight and outerWidth with\n  Velocity, which is much more convenient for our purposes. Submitted\n  to Velocity as PR #485.\n*/\n\nimport Velocity from \"velocity\";\nvar VCSS = Velocity.CSS;\n\nfunction augmentDimension(name, element) {\n  var sides = name === 'width' ? ['Left', 'Right' ] : ['Top', 'Bottom'];\n\n  if (VCSS.getPropertyValue(element, \"boxSizing\").toString().toLowerCase() === 'border-box') {\n    /* in box-sizing mode, the VCSS width / height accessors already give the outerWidth / outerHeight. */\n    return 0;\n  } else {\n    var augment = 0;\n    var fields = ['padding'+sides[0], 'padding'+sides[1], 'border'+sides[0]+'Width', 'border'+sides[1]+'Width'];\n    for (var i = 0; i < fields.length; i++) {\n      var value = parseFloat(VCSS.getPropertyValue(element, fields[i]));\n      if (!isNaN(value)) {\n        augment += value;\n      }\n    }\n    return augment;\n  }\n}\n\nfunction outerDimension(name) {\n  return function(type, element, propertyValue) {\n    switch (type) {\n    case \"name\":\n      return name;\n    case \"extract\":\n      return parseFloat(propertyValue) + augmentDimension(name, element);\n    case \"inject\":\n      return (parseFloat(propertyValue) - augmentDimension(name, element)) + \"px\";\n    }\n  };\n}\n\nVCSS.Normalizations.registered.outerWidth = outerDimension('width');\nVCSS.Normalizations.registered.outerHeight = outerDimension('height');\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/config/deploy.js":"/* jshint node: true */\n\nmodule.exports = function(deployTarget) {\n  var ENV = {\n    build: {},\n    git: {}\n    // include other plugin configuration that applies to all deploy targets here\n  };\n\n  if (process.env.GITHUB_CREDENTIALS) {\n    ENV.git.repo = \"https://\" + process.env.GITHUB_CREDENTIALS + \"@github.com/ember-animation/liquid-fire\";\n  }\n\n  if (deployTarget === 'development') {\n    ENV.build.environment = 'development';\n    // configure other plugins for development deploy target here\n  }\n\n  if (deployTarget === 'staging') {\n    ENV.build.environment = 'production';\n    // configure other plugins for staging deploy target here\n  }\n\n  if (deployTarget === 'production') {\n    ENV.build.environment = 'production';\n    // configure other plugins for production deploy target here\n  }\n\n  // Note: if you need to build some configuration asynchronously, you can return\n  // a promise that resolves with the ENV object instead of returning the\n  // ENV object synchronously.\n  return ENV;\n};\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/config/environment.js":"/* eslint-env node */\n'use strict';\n\nmodule.exports = function(/* environment, appConfig */) {\n  return { };\n};\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/illiquid-model.js":"import Ember from 'ember';\nimport layout from \"liquid-fire/templates/components/illiquid-model\";\n\nconst IlliquidModel = Ember.Component.extend({\n  layout,\n  tagName: '',\n  didReceiveAttrs() {\n    if (!this.get('_fixedModel')) {\n      this.set('_fixedModel', this.get('model'));\n    }\n  }\n});\n\nIlliquidModel.reopenClass({\n  positionalParams: ['model']\n});\n\nexport default IlliquidModel;\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/-lf-get-outlet-state.js":"import Ember from 'ember';\nimport { getOutletStateTemplate } from 'liquid-fire/ember-internals';\n\nexport default Ember.Component.extend({\n  tagName: '',\n  layout: getOutletStateTemplate\n});\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-bind.js":"import Ember from 'ember';\nimport layout from 'liquid-fire/templates/components/liquid-bind';\n\nvar LiquidBind = Ember.Component.extend({\n  layout,\n  tagName: '',\n  positionalParams: ['value'], // needed for Ember 1.13.[0-5] and 2.0.0-beta.[1-3] support\n  forwardMatchContext: Ember.computed('matchContext', function() {\n    let m = this.get('matchContext');\n    if (!m) {\n      m = {};\n    }\n    if (!m.helperName) {\n      m.helperName = 'liquid-bind';\n    }\n    return m;\n  })\n});\n\nLiquidBind.reopenClass({\n  positionalParams: ['value']\n});\n\nexport default LiquidBind;\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-child.js":"import Ember from \"ember\";\nexport default Ember.Component.extend({\n  classNames: ['liquid-child'],\n\n  init() {\n    this._super(...arguments);\n    this._waitingFor = [];\n  },\n\n  didInsertElement() {\n    let $container = this.$();\n    if ($container) {\n      $container.css('visibility','hidden');\n    }\n    this._waitForAll().then(() => {\n      if (!this.isDestroying) {\n        this._waitingFor = null;\n        this.sendAction('liquidChildDidRender', this);\n      }\n    });\n  },\n\n  _isLiquidChild: true,\n  _waitForMe(promise) {\n    if (!this._waitingFor) {\n      return;\n    }\n    this._waitingFor.push(promise);\n    let ancestor = this.nearestWithProperty('_isLiquidChild');\n    if (ancestor) {\n      ancestor._waitForMe(promise);\n    }\n  },\n  _waitForAll() {\n    const promises = this._waitingFor;\n    this._waitingFor = [];\n    return Ember.RSVP.Promise.all(promises).then(() => {\n      if (this._waitingFor.length > 0) {\n        return this._waitForAll();\n      }\n    });\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-container.js":"import Ember from \"ember\";\nimport Growable from \"liquid-fire/growable\";\nimport { measure } from \"./liquid-measured\";\nimport layout from \"liquid-fire/templates/components/liquid-container\";\n\nexport default Ember.Component.extend(Growable, {\n  layout,\n  classNames: ['liquid-container'],\n\n  lockSize: function(elt, want) {\n    elt.outerWidth(want.width);\n    elt.outerHeight(want.height);\n  },\n\n  unlockSize: function() {\n    var doUnlock = () => {\n      this.updateAnimatingClass(false);\n      var elt = this.$();\n      if (elt) {\n        elt.css({width: '', height: ''});\n      }\n    };\n    if (this._scaling) {\n      this._scaling.then(doUnlock);\n    } else {\n      doUnlock();\n    }\n  },\n\n  // We're doing this manually instead of via classNameBindings\n  // because it depends on upward-data-flow, which generates warnings\n  // under Glimmer.\n  updateAnimatingClass(on){\n    if (this.isDestroyed) {\n      return;\n    }\n    if (on) {\n      this.$().addClass('liquid-animating');\n    } else {\n      this.$().removeClass('liquid-animating');\n    }\n  },\n\n  startMonitoringSize: Ember.on('didInsertElement', function() {\n    this._wasInserted = true;\n  }),\n\n  actions: {\n\n    willTransition: function(versions) {\n      if (!this._wasInserted) {\n        return;\n      }\n\n      // Remember our own size before anything changes\n      var elt = this.$();\n      this._cachedSize = measure(elt);\n\n      // And make any children absolutely positioned with fixed sizes.\n      for (var i = 0; i < versions.length; i++) {\n        goAbsolute(versions[i]);\n      }\n\n    },\n\n    afterChildInsertion: function(versions) {\n      var elt = this.$();\n      var enableGrowth = this.get('enableGrowth') !== false;\n\n      // Measure children\n      var sizes = [];\n      for (var i = 0; i < versions.length; i++) {\n        if (versions[i].view) {\n          sizes[i] = measure(versions[i].view.$());\n        }\n      }\n\n      // Measure ourself again to see how big the new children make\n      // us.\n      var want = measure(elt);\n      var have = this._cachedSize || want;\n\n      // Make ourself absolute\n      if (enableGrowth) {\n        this.lockSize(elt, have);\n      } else {\n        this.lockSize(elt, {\n          height: Math.max(want.height, have.height),\n          width: Math.max(want.width, have.width)\n        });\n      }\n\n      // Apply '.liquid-animating' to liquid-container allowing\n      // any customizable CSS control while an animating is occuring\n      this.updateAnimatingClass(true);\n\n      // Make the children absolute and fixed size.\n      for (i = 0; i < versions.length; i++) {\n        goAbsolute(versions[i], sizes[i]);\n      }\n\n      // Kick off our growth animation\n      if (enableGrowth) {\n        this._scaling = this.animateGrowth(elt, have, want);\n      }\n    },\n\n    afterTransition: function(versions) {\n      for (var i = 0; i < versions.length; i++) {\n        goStatic(versions[i]);\n      }\n      this.unlockSize();\n    }\n  }\n});\n\nfunction goAbsolute(version, size) {\n  if (!version.view) {\n    return;\n  }\n  var elt = version.view.$();\n  var pos = elt.position();\n  if (!size) {\n    size = measure(elt);\n  }\n  elt.outerWidth(size.width);\n  elt.outerHeight(size.height);\n  elt.css({\n    position: 'absolute',\n    top: pos.top,\n    left: pos.left\n  });\n}\n\nfunction goStatic(version) {\n  if (version.view && !version.view.isDestroyed) {\n    version.view.$().css({width: '', height: '', position: ''});\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-if.js":"import Ember from 'ember';\nimport layout from \"liquid-fire/templates/components/liquid-if\";\n\nvar LiquidIf = Ember.Component.extend({\n  positionalParams: ['predicate'], // needed for Ember 1.13.[0-5] and 2.0.0-beta.[1-3] support\n  layout,\n  tagName: '',\n  helperName: 'liquid-if'\n});\n\nLiquidIf.reopenClass({\n  positionalParams: ['predicate']\n});\n\nexport default LiquidIf;\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-measured.js":"import MutationObserver from \"liquid-fire/mutation-observer\";\nimport Ember from \"ember\";\nimport layout from \"liquid-fire/templates/components/liquid-measured\";\n\nexport default Ember.Component.extend({\n  layout,\n\n  init() {\n    this._super(...arguments);\n    this._destroyOnUnload = this._destroyOnUnload.bind(this);\n  },\n\n  didInsertElement: function() {\n    var self = this;\n\n    // This prevents margin collapse\n    this.$().css({\n      overflow: 'auto'\n    });\n\n    this.didMutate();\n\n    this.observer = new MutationObserver(function(mutations) { self.didMutate(mutations); });\n    this.observer.observe(this.get('element'), {\n      attributes: true,\n      subtree: true,\n      childList: true,\n      characterData: true\n    });\n    this.$().bind('webkitTransitionEnd', function() { self.didMutate(); });\n    // Chrome Memory Leak: https://bugs.webkit.org/show_bug.cgi?id=93661\n    window.addEventListener('unload', this._destroyOnUnload);\n  },\n\n  willDestroyElement: function() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    window.removeEventListener('unload', this._destroyOnUnload);\n  },\n\n  transitionMap: Ember.inject.service('liquid-fire-transitions'),\n\n  didMutate: function() {\n    // by incrementing the running transitions counter here we prevent\n    // tests from falling through the gap between the time they\n    // triggered mutation the time we may actually animate in\n    // response.\n    var tmap = this.get('transitionMap');\n    tmap.incrementRunningTransitions();\n    Ember.run.next(this, function() {\n      this._didMutate();\n      tmap.decrementRunningTransitions();\n    });\n  },\n\n  _didMutate: function() {\n    var elt = this.$();\n    if (!elt || !elt[0]) { return; }\n    this.set('measurements', measure(elt));\n  },\n\n  _destroyOnUnload() {\n    this.willDestroyElement();\n  }\n});\n\nexport function measure($elt) {\n  return $elt[0].getBoundingClientRect();\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-outlet.js":"import Ember from \"ember\";\nimport layout from 'liquid-fire/templates/components/liquid-outlet';\nimport {\n  childRoute,\n  routeIsStable,\n  modelIsStable\n} from 'liquid-fire/ember-internals';\n\nvar LiquidOutlet = Ember.Component.extend({\n  layout,\n  positionalParams: ['inputOutletName'], // needed for Ember 1.13.[0-5] and 2.0.0-beta.[1-3] support\n  tagName: '',\n  versionEquality: Ember.computed('outletName', 'watchModels', function() {\n    let outletName = this.get('outletName');\n    let watchModels = this.get('watchModels');\n    return function(oldValue, newValue) {\n      let oldChild = childRoute(oldValue, outletName);\n      let newChild = childRoute(newValue, outletName);\n      return routeIsStable(oldChild, newChild) && (!watchModels || modelIsStable(oldChild, newChild));\n    };\n  }),\n  didReceiveAttrs() {\n    this._super(...arguments);\n    this.set('outletName', this.get('inputOutletName') || 'main');\n  }\n});\n\nLiquidOutlet.reopenClass({\n  positionalParams: ['inputOutletName']\n});\n\nexport default LiquidOutlet;\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-spacer.js":"import { measure } from \"./liquid-measured\";\nimport Growable from \"liquid-fire/growable\";\nimport Ember from \"ember\";\nimport layout from \"liquid-fire/templates/components/liquid-spacer\";\n\nexport default Ember.Component.extend(Growable, {\n  layout,\n  enabled: true,\n\n  didInsertElement: function() {\n    var child = this.$('> div');\n    var measurements = this.myMeasurements(measure(child));\n    var elt = this.$();\n    elt.css('overflow', 'hidden');\n    if (this.get('growWidth')) {\n      elt.outerWidth(measurements.width);\n    }\n    if (this.get('growHeight')) {\n      elt.outerHeight(measurements.height);\n    }\n  },\n\n  sizeChange: Ember.observer('measurements', function() {\n    if (!this.get('enabled')) { return; }\n    var elt = this.$();\n    if (!elt || !elt[0]) { return; }\n    var want = this.myMeasurements(this.get('measurements'));\n    var have = measure(this.$());\n    this.animateGrowth(elt, have, want);\n  }),\n\n  // given our child's outerWidth & outerHeight, figure out what our\n  // outerWidth & outerHeight should be.\n  myMeasurements: function(childMeasurements) {\n    var elt = this.$();\n    return {\n      width: childMeasurements.width + sumCSS(elt, padding('width')) + sumCSS(elt, border('width')),\n      height: childMeasurements.height + sumCSS(elt, padding('height')) + sumCSS(elt, border('height'))\n    };\n    //if (this.$().css('box-sizing') === 'border-box') {\n  }\n\n});\n\nfunction sides(dimension) {\n  return dimension === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];\n}\n\nfunction padding(dimension) {\n  var s = sides(dimension);\n  return ['padding'+s[0], 'padding'+s[1]];\n}\n\nfunction border(dimension) {\n  var s = sides(dimension);\n  return ['border'+s[0]+'Width', 'border'+s[1]+'Width'];\n}\n\nfunction sumCSS(elt, fields) {\n  var accum = 0;\n  for (var i=0; i < fields.length; i++) {\n    var num = parseFloat(elt.css(fields[i]), 10);\n    if (!isNaN(num)) {\n      accum += num;\n    }\n  }\n  return accum;\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-sync.js":"import Ember from 'ember';\nimport layout from '../templates/components/liquid-sync';\nimport Pausable from '../mixins/pausable';\n\nexport default Ember.Component.extend(Pausable, {\n  tagName: '',\n  layout: layout,\n  didInsertElement() {\n    this.pauseLiquidFire();\n  },\n  actions: {\n    ready() {\n      this.resumeLiquidFire();\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-unless.js":"import LiquidIf from './liquid-if';\n\nexport default LiquidIf.extend({\n  helperName: 'liquid-unless',\n  inverted: true\n});\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/components/liquid-versions.js":"import Ember from \"ember\";\nimport { containingElement } from \"liquid-fire/ember-internals\";\nimport layout from 'liquid-fire/templates/components/liquid-versions';\n\nvar get = Ember.get;\nvar set = Ember.set;\n\nexport default Ember.Component.extend({\n  layout,\n  tagName: \"\",\n\n  transitionMap: Ember.inject.service('liquid-fire-transitions'),\n\n  didReceiveAttrs() {\n    this._super(...arguments);\n    this.appendVersion();\n  },\n\n  appendVersion() {\n    var versions = this.versions;\n    var firstTime = false;\n    var newValue = this.getAttr('value');\n    var oldValue;\n    let versionEquality = this.get('versionEquality') || defaultEqualityCheck;\n\n    if (!versions) {\n      firstTime = true;\n      versions = Ember.A();\n    } else {\n      if (versions[0]) {\n        oldValue = versions[0].value;\n      }\n    }\n\n    if (!firstTime && versionEquality(oldValue, newValue)) {\n      if (versions[0] && versionEquality !== defaultEqualityCheck) {\n        // When using custom equality checkers, we may consider values\n        // equal for our purposes that are not `===`. In that case, we\n        // still need to thread updated values through to our children\n        // so they have their own opportunity to react.\n        Ember.set(versions[0], 'value', newValue);\n      }\n      return;\n    }\n\n    this.notifyContainer('willTransition', versions);\n    var newVersion = {\n      value: newValue\n    };\n    versions.unshiftObject(newVersion);\n\n    this.firstTime = firstTime;\n    if (firstTime) {\n      set(this, 'versions', versions);\n    }\n\n    if (!(newValue || this.get('renderWhenFalse') || firstTime)) {\n      this._transition();\n    }\n  },\n\n  _transition: function() {\n    var versions = get(this, 'versions');\n    var transition;\n    var firstTime = this.firstTime;\n    this.firstTime = false;\n\n\n    this.notifyContainer('afterChildInsertion', versions);\n\n    transition = get(this, 'transitionMap').transitionFor({\n      versions: versions,\n      parentElement: Ember.$(containingElement(this)),\n      use: get(this, 'use'),\n      rules: get(this, 'rules'),\n      matchContext: get(this, 'matchContext') || {},\n      // Using strings instead of booleans here is an\n      // optimization. The constraint system can match them more\n      // efficiently, since it treats boolean constraints as generic\n      // \"match anything truthy/falsy\" predicates, whereas string\n      // checks are a direct object property lookup.\n      firstTime: firstTime ? 'yes' : 'no',\n    });\n\n    if (this._runningTransition) {\n      this._runningTransition.interrupt();\n    }\n    this._runningTransition = transition;\n\n    transition.run().then((wasInterrupted) => {\n      // if we were interrupted, we don't handle the cleanup because\n      // another transition has already taken over.\n      if (!wasInterrupted) {\n        this.finalizeVersions(versions);\n        this.notifyContainer(\"afterTransition\", versions);\n      }\n    }, (err) => {\n      this.finalizeVersions(versions);\n      this.notifyContainer(\"afterTransition\", versions);\n      throw err;\n    });\n\n  },\n\n  finalizeVersions: function(versions) {\n    versions.replace(1, versions.length - 1);\n  },\n\n  notifyContainer: function(method, versions) {\n    var target = get(this, 'notify');\n    if (target) {\n      target.send(method, versions);\n    }\n  },\n\n  actions: {\n    childDidRender: function(child) {\n      var version = get(child, 'version');\n      set(version, 'view', child);\n      this._transition();\n    }\n  }\n\n});\n\n// All falsey values are considered equal, everything else gets strict\n// equality.\nfunction defaultEqualityCheck(a, b) {\n  return (!a && !b) || a === b;\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/ember-internals/common.js":"import Ember from \"ember\";\n\n// Traverses down to the child routeInfo with the given name.\nexport function childRoute(routeInfo, outletName) {\n  let outlets;\n  // TODO: the second condition is only necessary because every\n  // constrainable accessor runs against every value all the time. It\n  // would be better to add a precondition on helperName that would\n  // short-circuit this elsewhere.\n  if (routeInfo && (outlets = routeInfo.outlets)) {\n    return outlets[outletName];\n  }\n}\n\n// Finds the route name from a route state so we can apply our\n// matching rules to it.\nexport function routeName(routeInfo) {\n  if (routeInfo) {\n    return [routeInfo.render.name];\n  }\n}\n\n// Finds the route's model from a route state so we can apply our\n// matching rules to it. On first access, will lock down the value of\n// the model so that future changes don't change the answer. This lets\n// us avoid the problem of singleton controllers changing underneath\n// us.\nexport function routeModel(routeInfo) {\n  if (routeInfo && !routeInfo.hasOwnProperty('_lf_model')) {\n    let r, c;\n    if ((r = routeInfo.render) && (c = r.controller)) {\n      routeInfo._lf_model = Ember.get(c, 'model');\n    } else {\n      routeInfo._lf_model = null;\n    }\n  }\n\n  if (routeInfo) {\n    return [routeInfo._lf_model];\n  } else {\n    return [];\n  }\n}\n\nexport function routeIsStable(oldRouteInfo, newRouteInfo) {\n  if (!oldRouteInfo && !newRouteInfo) {\n    return true;\n  }\n\n  if (!oldRouteInfo || !newRouteInfo) {\n    return false;\n  }\n\n  return oldRouteInfo.render.template === newRouteInfo.render.template &&\n    oldRouteInfo.render.controller === newRouteInfo.render.controller;\n}\n\n// Only valid for states that already satisfy routeIsStable\nexport function modelIsStable(oldRouteInfo, newRouteInfo) {\n  let oldModel = routeModel(oldRouteInfo) || [];\n  let newModel = routeModel(newRouteInfo) || [];\n  return  oldModel[0] === newModel[0];\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/helpers/lf-lock-model.js":"import Ember from 'ember';\nimport { childRoute, routeModel } from '../ember-internals';\n\nexport function lfLockModel([routeInfo, outletName]) {\n  // ensures that the name is locked, see implementation of `routeModel`\n  routeModel(childRoute(routeInfo, outletName));\n  return routeInfo;\n}\n\nexport default Ember.Helper.helper(lfLockModel);\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/helpers/lf-or.js":"import Ember from 'ember';\n\nexport function lfOr(params/*, hash*/) {\n  return params.reduce((a,b) => a || b, false);\n}\n\nexport default Ember.Helper.helper(lfOr);\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/mixins/pausable.js":"import Ember from 'ember';\n\nexport default Ember.Mixin.create({\n  _transitionMap: Ember.inject.service('liquid-fire-transitions'),\n\n  _initializeLiquidFirePauseable: Ember.on('init', function() {\n    this._lfDefer = [];\n  }),\n  pauseLiquidFire() {\n    const context = this.nearestWithProperty('_isLiquidChild');\n    if (context) {\n      let defer = new Ember.RSVP.defer();\n      let tmap = this.get('_transitionMap');\n      tmap.incrementRunningTransitions();\n      defer.promise.finally(() => tmap.decrementRunningTransitions());\n      this._lfDefer.push(defer);\n      context._waitForMe(defer.promise);\n    }\n  },\n  resumeLiquidFire: Ember.on('willDestroyElement', function(){\n    let defer = this._lfDefer.pop();\n    if (defer) {\n      defer.resolve();\n    }\n  })\n});\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/cross-fade.js":"// BEGIN-SNIPPET cross-fade-definition\nimport { animate, stop, Promise } from \"liquid-fire\";\nexport default function crossFade(opts={}) {\n  stop(this.oldElement);\n  return Promise.all([\n    animate(this.oldElement, {opacity: 0}, opts),\n    animate(this.newElement, {opacity: [(opts.maxOpacity || 1), 0]}, opts)\n  ]);\n}\n// END-SNIPPET\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/default.js":"import { Promise } from \"liquid-fire\";\n\n// This is what we run when no animation is asked for. It just sets\n// the newly-added element to visible (because we always start them\n// out invisible so that transitions can control their initial\n// appearance).\nexport default function defaultTransition() {\n  if (this.newElement) {\n    this.newElement.css({visibility: ''});\n  }\n  return Promise.resolve();\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/explode.js":"import Ember from \"ember\";\nimport { Promise } from \"liquid-fire\";\n\n// Explode is not, by itself, an animation. It exists to pull apart\n// other elements so that each of the pieces can be targeted by\n// animations.\n\nexport default function explode(...pieces) {\n  var seenElements = {};\n  var sawBackgroundPiece = false;\n  var promises = pieces.map((piece) => {\n    if (piece.matchBy) {\n      return matchAndExplode(this, piece, seenElements);\n    } else if (piece.pick || piece.pickOld || piece.pickNew){\n      return explodePiece(this, piece, seenElements);\n    } else {\n      sawBackgroundPiece = true;\n      return runAnimation(this, piece);\n    }\n  });\n  if (!sawBackgroundPiece) {\n    if (this.newElement) {\n      this.newElement.css({visibility: ''});\n    }\n    if (this.oldElement) {\n      this.oldElement.css({visibility: 'hidden'});\n    }\n  }\n  return Promise.all(promises);\n}\n\nfunction explodePiece(context, piece, seen) {\n  var childContext = Ember.copy(context);\n  var selectors = [piece.pickOld || piece.pick, piece.pickNew || piece.pick];\n  var cleanupOld, cleanupNew;\n\n  if (selectors[0] || selectors[1]) {\n    cleanupOld = _explodePart(context, 'oldElement', childContext, selectors[0], seen);\n    cleanupNew = _explodePart(context, 'newElement', childContext, selectors[1], seen);\n    if (!cleanupOld && !cleanupNew) {\n      return Promise.resolve();\n    }\n  }\n\n  return runAnimation(childContext, piece).finally(() => {\n    if (cleanupOld) { cleanupOld(); }\n    if (cleanupNew) { cleanupNew(); }\n  });\n}\n\nfunction _explodePart(context, field, childContext, selector, seen) {\n  var child, childOffset, width, height, newChild;\n  var elt = context[field];\n\n  childContext[field] = null;\n  if (elt && selector) {\n    child = elt.find(selector).filter(function() {\n      var guid = Ember.guidFor(this);\n      if (!seen[guid]) {\n        seen[guid] = true;\n        return true;\n      }\n    });\n    if (child.length > 0) {\n      childOffset = child.offset();\n      width = child.outerWidth();\n      height = child.outerHeight();\n      newChild = child.clone();\n\n      // Hide the original element\n      child.css({visibility: 'hidden'});\n\n      // If the original element's parent was hidden, hide our clone\n      // too.\n      if (elt.css('visibility') === 'hidden') {\n        newChild.css({ visibility: 'hidden' });\n      }\n      newChild.appendTo(elt.parent());\n      newChild.outerWidth(width);\n      newChild.outerHeight(height);\n      var newParentOffset = newChild.offsetParent().offset();\n      newChild.css({\n        position: 'absolute',\n        top: childOffset.top - newParentOffset.top,\n        left: childOffset.left - newParentOffset.left,\n        margin: 0\n      });\n\n      // Pass the clone to the next animation\n      childContext[field] = newChild;\n      return function cleanup() {\n        newChild.remove();\n        child.css({visibility: ''});\n      };\n    }\n  }\n}\n\nfunction animationFor(context, piece) {\n  var name, args, func;\n  if (!piece.use) {\n    throw new Error(\"every argument to the 'explode' animation must include a followup animation to 'use'\");\n  }\n  if (Ember.isArray(piece.use) ) {\n    name = piece.use[0];\n    args = piece.use.slice(1);\n  } else {\n    name = piece.use;\n    args = [];\n  }\n  if (typeof name === 'function') {\n    func = name;\n  } else {\n    func = context.lookup(name);\n  }\n  return function() {\n    return Promise.resolve(func.apply(this, args));\n  };\n}\n\nfunction runAnimation(context, piece) {\n  return new Promise((resolve, reject) => {\n    animationFor(context, piece).apply(context).then(resolve, reject);\n  });\n}\n\nfunction matchAndExplode(context, piece, seen) {\n  if (!context.oldElement || !context.newElement) {\n    return Promise.resolve();\n  }\n\n  // reduce the matchBy scope\n  if (piece.pick) {\n    context.oldElement = context.oldElement.find(piece.pick);\n    context.newElement = context.newElement.find(piece.pick);\n  }\n\n  if (piece.pickOld) {\n    context.oldElement = context.oldElement.find(piece.pickOld);\n  }\n\n  if (piece.pickNew) {\n    context.newElement = context.newElement.find(piece.pickNew);\n  }\n\n  // use the fastest selector available\n  var selector;\n\n  if (piece.matchBy === 'id') {\n    selector = (attrValue) => { return `#${attrValue}`; };\n  } else if (piece.matchBy === 'class') {\n    selector = (attrValue) => { return `.${attrValue}`; };\n  } else {\n    selector = (attrValue) => {\n      var escapedAttrValue = attrValue.replace(/'/g, \"\\\\'\");\n      return `[${piece.matchBy}='${escapedAttrValue}']`;\n    };\n  }\n\n  var hits = Ember.A(context.oldElement.find(`[${piece.matchBy}]`).toArray());\n  return Promise.all(hits.map((elt) => {\n    var attrValue = Ember.$(elt).attr(piece.matchBy);\n\n    // if there is no match for a particular item just skip it\n    if (attrValue === \"\" || context.newElement.find(selector(attrValue)).length === 0) {\n      return Promise.resolve();\n    }\n\n    return explodePiece(context, {\n      pick: selector(attrValue),\n      use: piece.use\n    }, seen);\n  }));\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/fade.js":"// BEGIN-SNIPPET fade-definition\nimport { isAnimating, finish, timeSpent, animate, stop } from \"liquid-fire\";\nexport default function fade(opts={}) {\n  var firstStep;\n  var outOpts = opts;\n  var fadingElement = findFadingElement(this);\n\n  if (fadingElement) {\n    // We still have some older version that is in the process of\n    // fading out, so out first step is waiting for it to finish.\n    firstStep = finish(fadingElement, 'fade-out');\n  } else {\n    if (isAnimating(this.oldElement, 'fade-in')) {\n      // if the previous view is partially faded in, scale its\n      // fade-out duration appropriately.\n      outOpts = { duration: timeSpent(this.oldElement, 'fade-in') };\n    }\n    stop(this.oldElement);\n    firstStep = animate(this.oldElement, {opacity: 0}, outOpts, 'fade-out');\n  }\n  return firstStep.then(() => {\n    return animate(this.newElement, {opacity: [(opts.maxOpacity || 1), 0]}, opts, 'fade-in');\n  });\n}\n\nfunction findFadingElement(context) {\n  for (var i = 0; i < context.older.length; i++) {\n    var entry = context.older[i];\n    if (isAnimating(entry.element, 'fade-out')) {\n      return entry.element;\n    }\n  }\n  if (isAnimating(context.oldElement, 'fade-out')) {\n    return context.oldElement;\n  }\n}\n// END-SNIPPET\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/flex-grow.js":"import { animate, stop, Promise } from \"liquid-fire\";\nexport default function flexGrow(opts) {\n  stop(this.oldElement);\n  return Promise.all([\n    animate(this.oldElement, {'flex-grow': 0}, opts),\n    animate(this.newElement, {'flex-grow': [1, 0]}, opts)\n  ]);\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/fly-to.js":"import { animate, Promise } from \"liquid-fire\";\n\nexport default function flyTo(opts={}) {\n  if (!this.newElement) {\n    return Promise.resolve();\n  } else if (!this.oldElement) {\n    this.newElement.css({visibility: ''});\n    return Promise.resolve();\n  }\n\n  var oldOffset = this.oldElement.offset();\n  var newOffset = this.newElement.offset();\n\n\n  if (opts.movingSide === 'new') {\n    let motion = {\n      translateX: [0, oldOffset.left - newOffset.left],\n      translateY: [0, oldOffset.top - newOffset.top],\n      outerWidth: [this.newElement.outerWidth(), this.oldElement.outerWidth()],\n      outerHeight: [this.newElement.outerHeight(), this.oldElement.outerHeight()]\n    };\n    this.oldElement.css({ visibility: 'hidden' });\n    return animate(this.newElement, motion, opts);\n  } else {\n    let motion = {\n      translateX: newOffset.left - oldOffset.left,\n      translateY: newOffset.top - oldOffset.top,\n      outerWidth: this.newElement.outerWidth(),\n      outerHeight: this.newElement.outerHeight()\n    };\n    this.newElement.css({ visibility: 'hidden' });\n    return animate(this.oldElement, motion, opts).then(() => {\n      this.newElement.css({ visibility: ''});\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/move-over.js":"import { stop, animate, Promise, isAnimating, finish } from \"liquid-fire\";\n\nexport default function moveOver(dimension, direction, opts) {\n  var oldParams = {},\n      newParams = {},\n      firstStep,\n      property,\n      measure;\n\n  if (dimension.toLowerCase() === 'x') {\n    property = 'translateX';\n    measure = 'width';\n  } else {\n    property = 'translateY';\n    measure = 'height';\n  }\n\n  if (isAnimating(this.oldElement, 'moving-in')) {\n    firstStep = finish(this.oldElement, 'moving-in');\n  } else {\n    stop(this.oldElement);\n    firstStep = Promise.resolve();\n  }\n\n  return firstStep.then(() => {\n    var bigger = biggestSize(this, measure);\n    oldParams[property] = (bigger * direction) + 'px';\n    newParams[property] = [\"0px\", (-1 * bigger * direction) + 'px'];\n\n    return Promise.all([\n      animate(this.oldElement, oldParams, opts),\n      animate(this.newElement, newParams, opts, 'moving-in')\n    ]);\n  });\n}\n\nfunction biggestSize(context, dimension) {\n  var sizes = [];\n  if (context.newElement) {\n    sizes.push(parseInt(context.newElement.css(dimension), 10));\n    sizes.push(parseInt(context.newElement.parent().css(dimension), 10));\n  }\n  if (context.oldElement) {\n    sizes.push(parseInt(context.oldElement.css(dimension), 10));\n    sizes.push(parseInt(context.oldElement.parent().css(dimension), 10));\n  }\n  return Math.max.apply(null, sizes);\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/scale.js":"import { animate } from \"liquid-fire\";\n\nexport default function scale(opts={}) {\n  return animate(this.oldElement, {scale: [0.2, 1]}, opts).then(() => {\n    return animate(this.newElement, {scale: [1, 0.2]}, opts);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/scroll-then.js":"import Ember from 'ember';\nimport isBrowser from \"liquid-fire/is-browser\";\n\nexport default function(nextTransitionName, options, ...rest) {\n  if (isBrowser()) {\n    Ember.assert(\n      \"You must provide a transition name as the first argument to scrollThen. Example: this.use('scrollThen', 'toLeft')\",\n      'string' === typeof nextTransitionName\n    );\n\n    var el = document.getElementsByTagName('html');\n    var nextTransition = this.lookup(nextTransitionName);\n    if (!options) {  options = {}; }\n\n    Ember.assert(\n      \"The second argument to scrollThen is passed to Velocity's scroll function and must be an object\",\n      'object' === typeof options\n    );\n\n    // set scroll options via: this.use('scrollThen', 'ToLeft', {easing: 'spring'})\n    options = Ember.merge({duration: 500, offset: 0}, options);\n\n    // additional args can be passed through after the scroll options object\n    // like so: this.use('scrollThen', 'moveOver', {duration: 100}, 'x', -1);\n\n    return window.$.Velocity(el, 'scroll', options).then(() => {\n      nextTransition.apply(this, rest);\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/to-down.js":"import moveOver from \"./move-over\";\nexport default function(opts) {\n  return moveOver.call(this, 'y', 1, opts);\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/to-left.js":"import moveOver from \"./move-over\";\nexport default function(opts) {\n  return moveOver.call(this, 'x', -1, opts);\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/to-right.js":"import moveOver from \"./move-over\";\nexport default function(opts) {\n  return moveOver.call(this, 'x', 1, opts);\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/to-up.js":"import moveOver from \"./move-over\";\nexport default function(opts) {\n  return moveOver.call(this, 'y', -1, opts);\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/addon/transitions/wait.js":"import Ember from 'ember';\n\nexport default function(ms, opts={}) {\n  return new Ember.RSVP.Promise(resolve => {\n    setTimeout(() => {\n      resolve(this.lookup(opts.then || 'default').call(this));\n    }, ms);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/app/initializers/liquid-fire.js":"import { initialize } from \"liquid-fire/ember-internals\";\n\ninitialize();\n\nexport default {\n  name: 'liquid-fire',\n  initialize: function() {}\n};\n","/home/travis/build/npmtest/node-npmtest-liquid-fire/node_modules/liquid-fire/app/services/liquid-fire-transitions.js":"import TransitionMap from \"liquid-fire/transition-map\";\nexport default TransitionMap;\n"}